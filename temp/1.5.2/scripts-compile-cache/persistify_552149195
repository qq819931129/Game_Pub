{"persistifyArgs":{"cache":{"/Users/joker/Desktop/demo/NewProject/library/imports/4b/4b8fccb7-65d4-4f03-9b28-8532bf1ba8f6.js":{"source":"\"use strict\";\ncc._RF.push(module, '4b8fcy3ZdRPA5sohTK/G6j2', 'hero_basic');\n// test/js/hero_data/hero_basic.js\n\n\"use strict\";\n\n// Learn cc.Class:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/class.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/class.html\n// Learn Attribute:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/reference/attributes.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/life-cycle-callbacks.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/life-cycle-callbacks.html\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        groupId: null, //英雄敌我阵容标识\n        heroName: null, //英雄预存资源生成名称\n        x: null, //英雄当前所处格子的x轴\n        y: null, //英雄当前所处格子的y轴\n        point: null, //英雄标记  纪录具体是哪个英雄\n        route: [], //英雄移动路线   状态切换为移动时，赋值路线\n        state: 10 //英雄状态   10：静止，11：移动\n    },\n\n    // onLoad () {},\n\n    start: function start() {}\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/53/53073d40-572b-47eb-93ec-d446b3b3dec0.js":{"source":"\"use strict\";\ncc._RF.push(module, '530731AVytH65Ps1Eazs97A', 'dataControl');\n// test/js/dataControl.js\n\n\"use strict\";\n\n//英雄详细数据存储\nmodule.exports.updateHeroList = function (target) {\n    this.heroList = target;\n};\nmodule.exports.getHeroList = function () {\n    return this.heroList;\n};\n//关卡id存储\nmodule.exports.setcheckId = function (json) {\n    this.checkId = json;\n};\nmodule.exports.getcheckId = function () {\n    return this.checkId;\n};\n//障碍物详细数据存储\nmodule.exports.setObstacle = function (json) {\n    this.obstacle = json;\n};\nmodule.exports.getObstacle = function () {\n    return this.obstacle;\n};\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/ae/aecd5776-0be7-4694-8f03-4fbf3e3d35d4.js":{"source":"\"use strict\";\ncc._RF.push(module, 'aecd5d2C+dGlI8DT78+PTXU', 'move');\n// test/js/move.js\n\n'use strict';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        pointA: {\n            default: null,\n            type: cc.Node\n        },\n        pointB: {\n            default: null,\n            type: cc.Node\n        }\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n\n        var middleX = Math.abs(this.pointA.getPosition().x) > Math.abs(this.pointB.getPosition().x) ? this.pointA.getPosition().x / 2 : this.pointB.getPosition().x / 2;\n        var middleY = Math.abs(this.pointA.getPosition().y) > Math.abs(this.pointB.getPosition().y) ? this.pointA.getPosition().y / 2 : this.pointB.getPosition().y / 2;\n\n        cc.log('x:' + middleX + ',y:' + middleY);\n\n        var bezier = [this.pointA.getPosition(), cc.p(middleX, middleY + (this.pointB.getPosition().x - this.pointA.getPosition().x) * 0.1), this.pointB.getPosition()];\n        var bezierTo = cc.bezierTo(1, bezier);\n        this.pointA.runAction(bezierTo);\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/f1/f104f1cc-eca7-4ba0-8cb6-660d1cb7e794.js":{"source":"\"use strict\";\ncc._RF.push(module, 'f104fHM7KdLoIy2Zg0ct+eU', 'teamBuild_Control');\n// test/js/teamBuild_Control.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {},\n\n    onLoad: function onLoad() {}\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/fd/fd672d14-58f3-433e-8857-71b99b941d75.js":{"source":"\"use strict\";\ncc._RF.push(module, 'fd6720UWPNDPohXcbmblB11', 'ColliderListener');\n// test/js/ColliderListener.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        // foo: {\n        //    default: null,\n        //    url: cc.Texture2D,  // optional, default is typeof default\n        //    serializable: true, // optional, default is true\n        //    visible: true,      // optional, default is true\n        //    displayName: 'Foo', // optional\n        //    readonly: false,    // optional, default is false\n        // },\n        // ...\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        cc.director.getCollisionManager().enabled = true;\n        cc.director.getCollisionManager().enabledDebugDraw = true;\n        // cc.director.getCollisionManager().enabledDrawBoundingBox = true;\n\n        this.touchingNumber = 0;\n    },\n\n    onCollisionEnter: function onCollisionEnter(other) {\n        this.node.color = cc.Color.RED;\n        this.touchingNumber++;\n    },\n\n    onCollisionStay: function onCollisionStay(other) {\n        // console.log('on collision stay');\n    },\n\n    onCollisionExit: function onCollisionExit() {\n        this.touchingNumber--;\n        if (this.touchingNumber === 0) {\n            this.node.color = cc.Color.WHITE;\n        }\n    }\n\n    // called every frame, uncomment this function to activate update callback\n    // update: function (dt) {\n\n    // },\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/75/757c4f18-2838-4e71-b0a2-78bd80e5163f.js":{"source":"\"use strict\";\ncc._RF.push(module, '757c48YKDhOcbCieL2A5RY/', 'checkPoint_Control');\n// test/js/checkPoint_Control.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        background: {\n            default: null,\n            type: cc.Node\n        }\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        cc.director.preloadScene(\"teamBuild\", function () {\n            cc.log(\"teamBuild 场景预加载完毕\");\n        });\n        /*cc.director.preloadScene(\"battleBuild\", function () {\n         cc.log(\"battleBuild 场景预加载完毕\");\n        });*/\n    }\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/c2/c219ebfc-fb2f-44e5-8aa9-f2f2fb7cfe12.js":{"source":"\"use strict\";\ncc._RF.push(module, 'c219ev8+y9E5Yqp8vL7fP4S', 'animHelper');\n// test/js/New/animHelper.js\n\n'use strict';\n\nvar animHelper = cc.Class({\n    extends: cc.Component,\n\n    properties: {\n        anim: {\n            default: null,\n            type: cc.Animation\n        },\n        animState: {\n            default: null,\n            type: cc.AnimationState,\n            visible: false\n        }\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n\n    getAnimState: function getAnimState() {\n        return this.animState;\n    },\n\n    playAttack: function playAttack() {\n        if (this.animState != null && this.animState.name === 'person-attack') {\n            return;\n        }\n        this.animState = this.anim.play('person-attack');\n    },\n\n    playMove: function playMove() {\n        if (this.animState != null && this.animState.name === 'person-move') {\n            return;\n        }\n        this.animState = this.anim.play('person-move');\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/5b/5bb65800-917f-4355-b645-9eea1c898d2a.js":{"source":"\"use strict\";\ncc._RF.push(module, '5bb65gAkX9DVbZFnuociY0q', 'flyerMove');\n// test/js/New/flyerMove.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        damage: 0,\n        targetNode: {\n            default: null,\n            type: cc.Node\n        },\n        targetDefPosition: 0,\n        deviation: 0\n    },\n    // use this for initialization\n    onLoad: function onLoad() {\n        //启用碰撞事件\n        cc.director.getCollisionManager().enabled = true;\n        //cc.director.getCollisionManager().enabledDebugDraw = true;\n        this.moveToPosition(this.targetDefPosition);\n    },\n    moveToPosition: function moveToPosition(position) {\n\n        var thisPosition = this.node.getPosition();\n        position = this.node.convertToNodeSpaceAR(position);\n\n        var middleX = Math.abs(position.x) > Math.abs(thisPosition.x) ? Math.abs(position.x) / 2 : Math.abs(thisPosition.x) / 2;\n        var middleY = Math.abs(position.y) > Math.abs(thisPosition.y) ? Math.abs(position.y) / 2 : Math.abs(thisPosition.y) / 2;\n\n        var bezier = [thisPosition, cc.p(middleX, middleY + (position.x - thisPosition.x) * 0.1), position];\n\n        var bezierTo = cc.bezierTo(1, bezier);\n        this.node.runAction(bezierTo);\n    },\n    /**\n     * 当碰撞产生的时候调用\n     * @param  {Collider} other 产生碰撞的另一个碰撞组件\n     * @param  {Collider} self  产生碰撞的自身的碰撞组件\n     */\n    onCollisionEnter: function onCollisionEnter(other, self) {\n        if (this.targetNode.name == other.node.parent.name) {\n            this.node.active = false;\n        }\n    },\n    update: function update() {}\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/65/650da195-e044-4451-81d0-e65e8e042d3c.js":{"source":"\"use strict\";\ncc._RF.push(module, '650daGV4EREUYHQ5l6OBC08', 'hpBarHelper');\n// test/js/New/hpBarHelper.js\n\n'use strict';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        //扣血数字显示集合\n        subtractHPList: {\n            default: null,\n            type: cc.Node\n        },\n        //扣血数字动画预载资源\n        subtractHPPrefab: {\n            default: null,\n            type: cc.Prefab\n        },\n        lifeBar: {\n            default: null,\n            type: cc.Node\n        }\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        this.lifeBar.progress = 1;\n    },\n    updateLifeBar: function updateLifeBar(progress) {\n        this.lifeBar.progress = progress;\n    },\n    showDamagePoint: function showDamagePoint(harm) {\n        var labal = cc.instantiate(this.subtractHPPrefab);\n        labal.getComponent(cc.Label).string = '-' + harm;\n        this.subtractHPList.addChild(labal);\n        labal.getComponent(cc.Animation).play();\n    }\n\n    // called every frame, uncomment this function to activate update callback\n    // update: function (dt) {\n\n    // },\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/f3/f3cdca6e-acfa-4db8-a234-94f9629da9f8.js":{"source":"\"use strict\";\ncc._RF.push(module, 'f3cdcpurPpNuKI0lPlinan4', 'batBox_basic');\n// test/js/batBox_data/batBox_basic.js\n\n\"use strict\";\n\n// Learn cc.Class:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/class.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/class.html\n// Learn Attribute:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/reference/attributes.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/life-cycle-callbacks.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/life-cycle-callbacks.html\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        batBoxName: null, //------------------------------该格子上的父级节点名字\n        bat_obstacle: null, //----------------------------该格子上障碍物id\n        bat_hero: null, //--------------------------------该格子上英雄id\n        box_current: 0, //--------------------------------该格子高亮标识\n        x: 0, //------------------------------------------该格子坐标x\n        y: 0 },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    // onLoad () {},\n\n    start: function start() {}\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/59/593c0e1a-50e1-4c39-904f-89555ee2a593.js":{"source":"\"use strict\";\ncc._RF.push(module, '593c04aUOFMOZBPiVVe4qWT', 'collTest');\n// test/js/batBox_data/collTest.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        moveSpeed: 100,\n        rotationSpeed: 90\n    },\n\n    // LIFE-CYCLE CALLBACKS:\n\n    onLoad: function onLoad() {},\n    update: function update(dt) {\n        this.node.x -= dt * this.moveSpeed;\n        this.node.rotation += dt * this.rotationSpeed;\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/1a/1ab86e0f-f9ca-4c44-aec6-a85c2e924880.js":{"source":"\"use strict\";\ncc._RF.push(module, '1ab864P+cpMRK7GqFwukkiA', 'colliderListener');\n// test/js/batBox_data/colliderListener.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        boxItem: null },\n    onLoad: function onLoad() {},\n    onEnable: function onEnable() {\n        cc.director.getCollisionManager().enabled = true;\n    },\n    onDisable: function onDisable() {\n        cc.director.getCollisionManager().enabled = false;\n    },\n    onCollisionEnter: function onCollisionEnter(other, self) {\n        this.boxItem = other.node;\n        //console.log(other, self);\n    },\n\n    onCollisionStay: function onCollisionStay(other, self) {\n        // console.log('on collision stay');\n    },\n\n    onCollisionExit: function onCollisionExit() {}\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/e8/e88e58c7-fdce-45aa-9c05-acae92c3e6f0.js":{"source":"\"use strict\";\ncc._RF.push(module, 'e88e5jH/c5FqpwFrK6Sw+bw', 'followMove');\n// test/js/batBox_data/followMove.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {},\n\n    onLoad: function onLoad() {\n        var self = this;\n        var tag = this.node;\n        var canvasPos = tag.convertToWorldSpace(0);\n        console.log(canvasPos);\n        console.log(tag);\n        console.log(tag.getPosition());\n        this.node.on(cc.Node.EventType.TOUCH_MOVE, function (event) {\n            var selfItem = this;\n            var touches = event.getTouches();\n            var self_x = touches[0].getLocationX();\n            var self_y = touches[0].getLocationY();\n            tag.x = self_x - canvasPos.x - 250;\n            tag.y = self_y - canvasPos.y - 0;\n            console.log();\n            console.log(event.getLocation(), \"目标xy：\" + tag.getPosition());\n        });\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/f3/f3f6d102-a1e5-43fb-bf70-b7f3dc048edb.js":{"source":"\"use strict\";\ncc._RF.push(module, 'f3f6dECoeVD+79wt/PcBI7b', 'checkPointData');\n// test/js/checkPointData.js\n\n\"use strict\";\n\n//导入外部脚本\nvar js_dataControl = require(\"dataControl\");\ncc.Class({\n\t\t\textends: cc.Component,\n\n\t\t\tproperties: {\n\t\t\t\t\t\tcheckId: 0\n\t\t\t},\n\t\t\tonLoad: function onLoad() {\n\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\tthis.node.on(cc.Node.EventType.TOUCH_START, function (event) {\n\t\t\t\t\t\t\t\t\tjs_dataControl.setcheckId(self.checkId);\n\t\t\t\t\t\t\t\t\tcc.director.loadScene(\"battleBuild\");\n\t\t\t\t\t\t});\n\t\t\t}\n});\n\ncc._RF.pop();","deps":{"dataControl":"/Users/joker/Desktop/demo/NewProject/library/imports/53/53073d40-572b-47eb-93ec-d446b3b3dec0.js"}},"/Users/joker/Desktop/demo/NewProject/library/imports/11/113e344f-026f-4af4-95fc-69a8499577ed.js":{"source":"\"use strict\";\ncc._RF.push(module, '113e3RPAm9K9JX8aahJlXft', 'body');\n// test/js/New/body.js\n\n'use strict';\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        person: { //身体节点\n            default: null,\n            type: cc.Node\n        }\n    },\n    onLoad: function onLoad() {\n        this.animHelper = this.getComponent('animHelper');\n        this.parentCopm = this.person.getComponent('person');\n\n        //启用碰撞事件\n        cc.director.getCollisionManager().enabled = true;\n        //cc.director.getCollisionManager().enabledDebugDraw = true;\n    },\n    update: function update() {},\n    attackOver: function attackOver() {\n        if (this.parentCopm.atkTarget == null || !this.parentCopm.atkTarget.activeInHierarchy || this.parentCopm.atkTarget.die == 0) {\n            return;\n        }\n        if (this.parentCopm.atkTargetDist <= this.parentCopm.atkDist) {\n            var damagePoint = this.parentCopm.atkPoint; //后面会加入伤害公式计算\n            this.parentCopm.atkTarget.getComponent('person').damage(damagePoint);\n        }\n        // else if(this.parentCopm.atkTargetDist >= this.parentCopm.atkRangedDistMin && this.parentCopm.atkTargetDist <= this.parentCopm.atkRangedDistMax){\n        //     //发射飞行物\n        //     this.parentCopm.createFlyer();\n        // }\n    },\n    moveOver: function moveOver() {\n        // cc.log('moveOver');\n    },\n\n    playAttack: function playAttack() {\n        this.animHelper.playAttack();\n    },\n\n    playMove: function playMove() {\n        this.animHelper.playMove();\n    },\n\n    getAnimState: function getAnimState() {\n        this.animHelper.getAnimState();\n    },\n    /**\n     * 当碰撞产生的时候调用\n     * @param  {Collider} other 产生碰撞的另一个碰撞组件\n     * @param  {Collider} self  产生碰撞的自身的碰撞组件\n     */\n    onCollisionEnter: function onCollisionEnter(other, self) {\n        var demage = other.node.getComponent('flyerMove').damage;\n        this.parentCopm.atkTarget.getComponent('person').damage(demage);\n    }\n\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/2f/2f3f0e1e-6074-4464-8a08-083e66045150.js":{"source":"\"use strict\";\ncc._RF.push(module, '2f3f04eYHREZIoICD5mBFFQ', 'prefabPool');\n// test/js/prefabPool.js\n\n\"use strict\";\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        enemyPrefab1: cc.Prefab,\n        enemyPrefab1Count: null\n    },\n    onLoad: function onLoad() {},\n    init: function init() {\n        this.enemyPool = new cc.NodePool();\n        for (var i = 0; i < this.enemyPrefab1Count; i++) {\n            var enemy = cc.instantiate(this.enemyPrefab1); // 创建节点\n            this.enemyPool.put(enemy); // 通过 putInPool 接口放入对象池\n        }\n    },\n    createEnemy: function createEnemy() {\n        var enemy = null;\n        if (this.enemyPool.size() > 0) {\n            // 通过 size 接口判断对象池中是否有空闲的对象\n            enemy = this.enemyPool.get();\n        } else {\n            // 如果没有空闲对象，也就是对象池中备用对象不够时，我们就用 cc.instantiate 重新创建\n            enemy = cc.instantiate(this.enemyPrefab1);\n        }\n        return enemy;\n    },\n    onEnemyKilled: function onEnemyKilled(enemy) {\n        // enemy 应该是一个 cc.Node\n        this.enemyPool.put(enemy); // 和初始化时的方法一样，将节点放进对象池，这个方法会同时调用节点的 removeFromParent\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/79/79f1b76b-694c-4d53-a911-018db2ddb276.js":{"source":"\"use strict\";\ncc._RF.push(module, '79f1bdraUxNU6kRAY2y3bJ2', 'pkLoad');\n// test/js/pkLoad.js\n\n'use strict';\n\ncc.Class({\n    extends: cc.Component,\n    properties: {\n        leftCamp: {\n            default: null,\n            type: cc.Node\n        },\n        rightCamp: {\n            default: null,\n            type: cc.Node\n        },\n        personPrefabNew: {\n            default: null,\n            type: cc.Prefab\n        }\n    },\n    onLoad: function onLoad() {\n        this.battle_Control = this.getComponent('battle_Control');\n        this.battle_Control.battleInit_basic(1);\n\n        this.perfabPool = this.getComponent(\"prefabPool\");\n        this.perfabPool.init();\n\n        // this.init();\n    },\n    init: function init() {\n        var person1 = this.perfabPool.createEnemy();\n        person1.getComponent('person').group = 'left';\n        person1.x = 250;\n        person1.y = 250;\n        person1.name = 'person1';\n        cc.log(person1);\n        this.leftCamp.addChild(person1);\n\n        var person2 = this.perfabPool.createEnemy();\n        person2.getComponent('person').body.scaleX = -1;\n        person2.getComponent('person').group = 'right';\n        person2.x = 750;\n        person2.y = 250;\n        person2.name = 'person2';\n        cc.log(person2);\n        this.rightCamp.addChild(person2);\n\n        var person3 = this.perfabPool.createEnemy();\n        person3.name = 'person3';\n        person3.getComponent('person').group = 'left'; //少了这个属性没赋值会抱错？？？？\n        person3.x = 250;\n        person3.y = 250;\n        cc.log(person3);\n        this.leftCamp.addChild(person3);\n\n        var person4 = this.perfabPool.createEnemy();\n        person4.name = 'person4';\n        person4.getComponent('person').body.scaleX = -1;\n        person4.getComponent('person').group = '11'; //少了这个属性没赋值会抱错？？？？\n        person4.x = 750;\n        person4.y = 250;\n        cc.log(person4);\n        this.rightCamp.addChild(person4);\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/7b/7b18cae2-b268-4dca-ab87-725aa35dfc68.js":{"source":"\"use strict\";\ncc._RF.push(module, '7b18crismhNyquHclqjXfxo', 'findAtkTarget');\n// test/js/New/findAtkTarget.js\n\n\"use strict\";\n\n//导入外部脚本\nvar js_dataControl = require(\"dataControl\");\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {},\n\n    // use this for initialization\n    onLoad: function onLoad() {},\n    //寻找最近的敌人（向量版）\n    // find: function (position, enemyCamp, atkDistMax) {\n    //     //key距离、value节点\n    //     var enemyMap = {};\n    //     var keyArray = new Array();\n    //     //循环查找目标\n    //     if (enemyCamp == null || enemyCamp.childrenCount == 0) {\n    //         return;\n    //     }\n    //     var enemys = enemyCamp.children;\n    //     for (var i = 0; i < enemys.length; i++) {\n    //         if (enemys[i] == null || enemys[i].getComponent('person').isDie()) {\n    //             continue;\n    //         }\n    //         var position = this.getTargetDistance(position, enemys[i]);\n    //         enemyMap[position] = enemys[i];\n    //         keyArray.push(position);\n    //     }\n    //     //冒泡排序，找到最近的目标\n    //     for (var i = 0; i < keyArray.length; i++) {\n    //         for (var j = i; j < keyArray.length; j++) {\n    //             if (keyArray[i] > keyArray[j]) {\n    //                 var key = keyArray[i];\n    //                 keyArray[i] = keyArray[j];\n    //                 keyArray[j] = key;\n    //             }\n    //         }\n    //     }\n    //     if (keyArray[0] <= atkDistMax) {\n    //         return enemyMap[keyArray[0]];\n    //     } else {\n    //         return null;\n    //     }\n    // },\n    // //获取距离\n    // getTargetDistance: function (position, atkTarget) {\n    //     if (atkTarget == null || atkTarget.getComponent('person').isDie()) {\n    //         return 9999;\n    //     }\n    //     return cc.pDistance(position, atkTarget.getPosition());\n    // },\n\n    //新寻敌、攻击方法（格子版）\n    findCanAtkGrid: function findCanAtkGrid(rowGrid, colGrid, atkDistMin, atkDistMax) {\n        var canAtkGrids = [];\n        var position = Number(rowGrid + '' + colGrid);\n        if (atkDistMin == atkDistMax) {\n            var _top = position + 10;\n            var _bottom = position - 10;\n            var _left = position - 1;\n            var _right = position + 1;\n            if (_top > 0 && _top <= 50) {\n                canAtkGrids.push(_top);\n            }\n            if (_bottom > 0 && _bottom <= 50) {\n                canAtkGrids.push(_bottom);\n            }\n            if (_left > 0 && _left <= 50 && _left.toString().substring(0, 1) == rowGrid) {\n                canAtkGrids.push(_left);\n            }\n            if (_right > 0 && _right <= 50 && _right.toString().substring(0, 1) == rowGrid) {\n                canAtkGrids.push(_right);\n            }\n        } else {\n            for (var i = 1; i <= atkDistMax; i++) {\n                var top = position + i * 10;\n                var bottom = position - i * 10;\n                var left = position - i;\n                var right = position + i;\n                if (top > 0 && top <= 50) {\n                    canAtkGrids.push(top);\n                }\n                if (bottom > 0 && bottom <= 50) {\n                    canAtkGrids.push(bottom);\n                }\n                if (left > 0 && left <= 50 && left.toString().substring(0, 1) == rowGrid) {\n                    canAtkGrids.push(left);\n                }\n                if (right > 0 && right <= 50 && right.toString().substring(0, 1) == rowGrid) {\n                    canAtkGrids.push(right);\n                }\n                //斜角\n                if (i < atkDistMax) {\n                    var topLeft = position + i * 11;\n                    var topRight = position - i * 9;\n                    var bottomLeft = position - i * 11;\n                    var bottomRight = position + i * 9;\n                    if (topLeft > 0 && topLeft <= 50) {\n                        canAtkGrids.push(topLeft);\n                    }\n                    if (topRight > 0 && topRight <= 50) {\n                        canAtkGrids.push(topRight);\n                    }\n                    if (bottomLeft > 0 && bottomLeft <= 50) {\n                        canAtkGrids.push(bottomLeft);\n                    }\n                    if (bottomRight > 0 && bottomRight <= 50) {\n                        canAtkGrids.push(bottomRight);\n                    }\n                }\n            }\n        }\n        return canAtkGrids;\n    },\n    findNew: function findNew(rowGrid, colGrid, atkDistMin, atkDistMax) {\n        if (js_dataControl.getHeroList() && js_dataControl.getHeroList().length > 0) {\n            var canAtkGrids = this.findCanAtkGrid(rowGrid, colGrid, atkDistMin, atkDistMax);\n            cc.log(canAtkGrids);\n            var canAtkTreget = {};\n            var gridList = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = canAtkGrids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var grid = _step.value;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = js_dataControl.getHeroList()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _temp = _step2.value;\n\n                            if (_temp.groupId == 2) {\n                                if (grid == _temp.boxId) {\n                                    canAtkTreget[_temp.boxId] = _temp;\n                                    gridList.push(_temp.boxId);\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            for (var i = 0; i < gridList.length; i++) {\n                for (var j = i; j < gridList.length; j++) {\n                    if (gridList[i] > gridList[j]) {\n                        var temp = gridList[i];\n                        gridList[i] = gridList[j];\n                        gridList[j] = temp;\n                    }\n                }\n            }\n            return canAtkTreget[gridList[0]];\n        }\n        return null;\n    }\n});\n\ncc._RF.pop();","deps":{"dataControl":"/Users/joker/Desktop/demo/NewProject/library/imports/53/53073d40-572b-47eb-93ec-d446b3b3dec0.js"}},"/Users/joker/Desktop/demo/NewProject/library/imports/29/29fb5e54-d47c-4b4f-8dc3-baca5c6f728f.js":{"source":"\"use strict\";\ncc._RF.push(module, '29fb55U1HxLT43Duspcb3KP', 'person');\n// test/js/New/person.js\n\n'use strict';\n\nvar AttackType = cc.Enum({\n    Melee: 1,\n    Range: 2\n});\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        atkPoint: 10, //攻击力\n        speed: 1, //游戏速度\n        atkDist: 500, //近身攻击距离\n        atkRangedDistMin: 501, //远程攻击最小距离\n        atkRangedDistMax: 800, //远程攻击最大距离\n        atkDistMax: 500, //最大攻击距离\n        defalutHP: 500, //默认生命值\n        allHP: 500, //当前生命值\n        die: 1, //是否死亡 1否 0是，默认否（1）\n        type: 0,\n        body: { //身体节点\n            default: null,\n            type: cc.Node\n        },\n        atkTargetDist: { //正在攻击的敌人的距离,需要实时更新\n            default: 0,\n            type: cc.Integer,\n            visible: false\n        },\n        group: null, //组，我方or敌方\n        atkTarget: { //正在攻击的敌人\n            default: null,\n            type: cc.Node,\n            visible: false\n        },\n        flyerList: { //飞行物数组\n            default: null,\n            type: cc.Node\n        },\n        flyer: { //飞行物资源\n            default: null,\n            type: cc.Prefab\n        },\n        groupId: null, //英雄敌我阵容标识\n        heroName: null, //英雄预存资源生成名称\n        x: null, //英雄当前所处格子的x轴\n        y: null, //英雄当前所处格子的y轴\n        point: null, //英雄标记  纪录具体是哪个英雄\n        route: [], //英雄移动路线   状态切换为移动时，赋值路线\n        state: 10 //英雄状态   10：静止，11：移动\n    },\n\n    // use this for initialization\n    onLoad: function onLoad() {\n        this.findAtkTarget = this.getComponent('findAtkTarget');\n        this.HPBar = this.getComponent('hpBarHelper');\n        this.bodyComp = this.body.getComponent('body');\n        this.personComp = this.getComponent('person');\n        this.enemyCamp = cc.find('/PK/' + (this.node.name.indexOf('left') > -1 ? 'rightCamp' : 'leftCamp'));\n        this.pk = cc.find('/PK');\n    },\n\n    // called every frame, uncomment this function to activate update callback\n    update: function update(dt) {\n        if (this.atkTarget == null) {\n            //TODO 移动\n\n            this.bodyComp.playMove();\n            //寻敌\n            this.atkTarget = this.findAtkTarget.findNew(this.y, this.x, this.atkRangedDistMin, this.atkRangedDistMax);\n            cc.log(this.atkTarget);\n        } else {\n            // var dist = this.findAtkTarget.getTargetDistance(this.node.getPosition(), this.atkTarget);\n            // this.atkTargetDist = dist;\n            // if(this.atkDistMax < this.atkTargetDist){\n            //     //清空目标，等下一次执行update时再寻找目标\n            //     this.bodyComp.playMove();\n            //     this.atkTarget = null; \n            // }else{    \n            //     //执行攻击动画\n            //     this.bodyComp.playAttack();\n            // }\n        }\n    },\n\n    createFlyer: function createFlyer() {\n        if (this.atkRangedDistMin && this.atkRangedDistMax) {\n            if (this.atkTarget != null) {\n                var flyer = cc.instantiate(this.flyer);\n                flyer.group = this.group;\n                flyer.anchorX = 0;\n                flyer.anchorY = 0;\n                flyer.setPosition(cc.v2(0, 0));\n                flyer.setPosition(this.pk.convertToNodeSpace(flyer.getPosition()));\n                flyer.getComponent('flyerMove').damage = this.atkPoint;\n                flyer.getComponent('flyerMove').targetNode = this.atkTarget;\n                flyer.getComponent('flyerMove').targetDefPosition = this.atkTarget.getPosition();\n                flyer.setLocalZOrder(10);\n                this.flyerList.addChild(flyer);\n                //flyer.getComponent('flyerMove').moveToPosition(this.atkTarget.getPosition());\n            }\n        }\n    },\n\n    isDie: function isDie() {\n        return !this.node.activeInHierarchy || this.die == 0 || this.HP <= 0;\n    },\n    goDie: function goDie() {\n        this.die = 0;\n        this.node.parent.active = false;\n    },\n    damage: function damage(damagePoint) {\n        this.allHP = this.allHP - damagePoint;\n        this.HPBar.updateLifeBar(this.allHP / this.defalutHP);\n        this.HPBar.showDamagePoint(damagePoint);\n        if (this.allHP <= 0) {\n            this.goDie();\n        }\n    },\n    enemyIsDie: function enemyIsDie() {\n        if (this.atkTarget.allHP <= 0) {\n            this.atkTarget.goDie();\n            this.atkTarget = null;\n            this.atkTargetDist = 0;\n            return true;\n        } else {\n            return false;\n        }\n    }\n});\n\ncc._RF.pop();","deps":{}},"/Users/joker/Desktop/demo/NewProject/library/imports/21/210fed25-15f2-4438-bf72-45abd19d702e.js":{"source":"\"use strict\";\ncc._RF.push(module, '210fe0lFfJEOL9yRavRnXAu', 'battle_Control');\n// test/js/battle_Control.js\n\n\"use strict\";\n\n//导入外部脚本\nvar js_dataControl = require(\"dataControl\");\n\ncc.Class({\n\textends: cc.Component,\n\n\tproperties: {\n\t\tcanvas: cc.Node,\n\t\titemPrefab: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tchoosePrefab: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_obstacle_01: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_obstacle_02: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_obstacle_03: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_hero_01: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_hero_02: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tPrefab_tempColl_touch: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tbackground: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Node\n\t\t},\n\t\tbatBox: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Node\n\t\t},\n\t\tother: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Node\n\t\t},\n\t\tenemy: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Node\n\t\t},\n\t\ticon_arrow: {\n\t\t\tdefault: null,\n\t\t\ttype: cc.Prefab\n\t\t},\n\t\tfollowSpeed: 1\n\t},\n\tupdate: function update(dt) {},\n\tonLoad: function onLoad() {},\n\t//生成第一层战场数组-基础数据  (关卡id，预存资源对象)\n\tbattleInit_basic: function battleInit_basic(checkId, personPrefabNew) {\n\t\t//初始化部分数组\n\t\tthis.batlist = []; //-----------------------------战场基础层\n\t\tthis.hero_list = []; //---------------------------战场英雄存储\n\t\tthis.obstacle_list = []; //-----------------------战场障碍物存储\n\t\tthis.hero_route_list = []; //---------------------英雄路线数据\n\t\tthis.hero_route_list.state = 0; //----------------英雄路线——是否可启用 0=不可用，1=可用\n\t\tthis.hero_route_list.name = null; //--------------英雄生成名字\n\t\tthis.hero_route_list.list = []; //----------------英雄路线——存储路线数组\n\t\tthis.hero_route_list.lastId = -1; //--------------英雄路线——记录上一次格子的名字  -1:初始     加入临时数组时进行赋值\n\t\tthis.hero_route_list.boxIndex = -1; //------------英雄路线——记录格子下标   -1:初始   \n\n\t\tthis.hero_route_ok_list = []; //---------------------中心点英雄路线数据\n\t\tthis.hero_route_ok_list.state = 0; //----------------中心点英雄路线——是否可启用 0=不可用，1=可用\n\t\tthis.hero_route_ok_list.name = null; //--------------中心点英雄生成名字\n\t\tthis.hero_route_ok_list.list = []; //----------------中心点英雄路线——存储路线数组\n\t\tthis.hero_route_ok_list.lastId = -1; //--------------中心点英雄路线——记录上一次格子的名字  -1:初始     加入确认数组时进行赋值\n\n\t\tthis.checkId = js_dataControl.getcheckId(); //-------获取关卡id\n\t\tvar bat = this.batBox.children;\n\t\tfor (var i = 0; i < bat.length; i++) {\n\t\t\tthis.batlist.push(bat[i].getComponent(\"batBox_basic\"));\n\t\t\tthis.batlist[i].batBoxName = bat[i].name;\n\t\t}\n\t\tconsole.log(this.batlist);\n\t\tcc.log(this);\n\t\tthis.perfabPool = this.getComponent(\"prefabPool\");\n\t\tthis.perfabPool.init();\n\t\tthis.battleInit_obstacle(this.checkId, personPrefabNew);\n\t},\n\t//生成第二层战场数组-障碍物   (关卡id)\n\tbattleInit_obstacle: function battleInit_obstacle(checkId, personPrefabNew) {\n\t\t//关卡序列\n\t\tif (checkId == 1) {\n\t\t\tvar otherList = [{ y: 0, x: 4, point: 1 }, { y: 2, x: 4, point: 2 }, { y: 1, x: 4, point: 3 }, { y: 1, x: 6, point: 1 }, { y: 2, x: 7, point: 1 }];\n\t\t}\n\t\tif (checkId == 2) {\n\t\t\tvar otherList = [{ y: 0, x: 4, point: 1 }, { y: 2, x: 4, point: 2 }, { y: 1, x: 4, point: 3 }];\n\t\t}\n\t\tfor (var i = 0; i < otherList.length; i++) {\n\t\t\t//-----匹配战场数组\n\t\t\tfor (var j = 0; j < this.batlist.length; j++) {\n\t\t\t\t//--------战场需要遍历50次，所以用batlist，而不用专门获取的batBox.getChildByName\n\t\t\t\tif (this.batlist[j].x == otherList[i].x && this.batlist[j].y == otherList[i].y) {\n\t\t\t\t\tthis.batlist[j].bat_obstacle = otherList[i].point;\n\t\t\t\t\tthis.battleInit_obstacle_detail(otherList[i].point, this.batlist[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconsole.log(this.obstacle_list);\n\t\tjs_dataControl.setObstacle(this.obstacle_list);\n\t\tthis.battleInit_hero(this.checkId, personPrefabNew);\n\t},\n\t//生成第三层战场数组-英雄   (关卡id)\n\tbattleInit_hero: function battleInit_hero(checkId, personPrefabNew) {\n\t\t//let tempList = [{y: 4,x: 2,point: 6},{y: 3,x: 2,point: 7},{y: 2,x: 2,point: 8},{y: 1,x: 2,point: 9},{y: 0,x: 2,point: 10},{y: 4,x: 1,point: 11}];//----我方阵容-测试用的\n\t\tvar tempList = [{ y: 4, x: 2, point: 6 }];\n\t\tvar otherList = []; //-----------------------我方阵容\n\t\tvar otherList_lock_id = 0; //----------------我方阵容——位置是否有重复英雄导入标识  0:是，1:不是\n\t\tvar otherList_lock_point = 0; //-------------我方阵容——不同年龄系列英雄是否重复导入标识  0:是，1:不是\n\t\t//let fulinList = [{id: \"01\",point: 1},{id: \"02\",point: 2},{id: \"03\",point: 3}];//------符灵技能栏\n\t\tif (checkId == 1) {\n\t\t\t//var enemyList = [{y: 4,x: 9,point: 1},{y: 2,x: 9,point: 2},{y: 0,x: 9,point: 3},{y: 3,x: 7,point: 4},{y: 1,x: 7,point: 5}];//----敌方阵容\n\t\t\tvar enemyList = [{ y: 4, x: 9, point: 1 }];\n\t\t}\n\t\tif (checkId == 2) {\n\t\t\tvar enemyList = [{ y: 3, x: 9, point: 1 }, { y: 1, x: 9, point: 2 }, { y: 0, x: 9, point: 3 }, { y: 0, x: 7, point: 4 }, { y: 1, x: 7, point: 5 }]; //----敌方阵容\n\t\t}\n\t\tfor (var i = 0; i < tempList.length; i++) {\n\t\t\t//我方阵容区域内\n\t\t\tif (tempList[i].id == \"00\" || tempList[i].id == \"10\" || tempList[i].id == \"20\" || tempList[i].id == \"30\" || tempList[i].id == \"40\" || tempList[i].id == \"01\" || tempList[i].id == \"11\" || tempList[i].id == \"21\" || tempList[i].id == \"31\" || tempList[i].id == \"41\" || tempList[i].id == \"02\" || tempList[i].id == \"12\" || tempList[i].id == \"22\" || tempList[i].id == \"32\" || tempList[i].id == \"42\") {\n\t\t\t\tif (otherList.length < 5) {\n\t\t\t\t\t//----------------------------不超出5个英雄选择\n\t\t\t\t\tfor (var j = 0; j < otherList.length; j++) {\n\t\t\t\t\t\tif (otherList[j].x == tempList[i].x && otherList[j].y == tempList[i].y) {\n\t\t\t\t\t\t\t//-------发现已有英雄的位置上再放英雄，标识此次操作不加入阵容数组\n\t\t\t\t\t\t\totherList_lock_id = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (otherList[j].point == tempList[i].point) {\n\t\t\t\t\t\t\t//---------发现放了不同年龄系列英雄，一个英雄分不同年龄阶段的卡牌\n\t\t\t\t\t\t\totherList_lock_point = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherList.length < 5) {\n\t\t\t\t//----------------------------不超出5个英雄选择\n\t\t\t\tif (otherList_lock_id == 0 && otherList_lock_point == 0) {\n\t\t\t\t\t//------标识们一致允许加入才能增加\n\t\t\t\t\totherList.push(tempList[i]);\n\t\t\t\t}\n\t\t\t\tif (otherList_lock_id == 1 || otherList_lock_point == 1) {\n\t\t\t\t\t//------标识们一致允许加入才能增加\n\t\t\t\t\totherList.pop();\n\t\t\t\t\totherList.push(tempList[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//初始化临时用的标识值\n\t\t\totherList_lock_id = 0;\n\t\t\totherList_lock_point = 0;\n\t\t}\n\n\t\tfor (var _i = 0; _i < otherList.length; _i++) {\n\t\t\t//-----我方英雄导入战场\n\t\t\tfor (var _j = 0; _j < this.batlist.length; _j++) {\n\t\t\t\t//--------战场需要遍历50次，所以用batlist，而不用专门获取的batBox.getChildByName\n\t\t\t\tif (this.batlist[_j].x == otherList[_i].x && this.batlist[_j].y == otherList[_i].y) {\n\t\t\t\t\tthis.batlist[_j].bat_hero = otherList[_i].point;\n\t\t\t\t\tthis.battleInit_hero_detail(otherList[_i].point, this.batlist[_j], 1, personPrefabNew);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var _i2 = 0; _i2 < enemyList.length; _i2++) {\n\t\t\t//-----敌方英雄导入战场\n\t\t\tfor (var _j2 = 0; _j2 < this.batlist.length; _j2++) {\n\t\t\t\t//--------战场需要遍历50次，所以用batlist，而不用专门获取的batBox.getChildByName\n\t\t\t\tif (this.batlist[_j2].x == enemyList[_i2].x && this.batlist[_j2].y == enemyList[_i2].y) {\n\t\t\t\t\tthis.batlist[_j2].bat_hero = enemyList[_i2].point;\n\t\t\t\t\tthis.battleInit_hero_detail(enemyList[_i2].point, this.batlist[_j2], 2, personPrefabNew);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjs_dataControl.updateHeroList(this.hero_list);\n\t},\n\t//选取格子高亮   (格子对象)\n\tcurrentBox: function currentBox(boxItem) {\n\t\tvar temp = this.batBox.getChildByName(\"batBox_y\" + boxItem.y + \"_x\" + boxItem.x);\n\t\tif (temp.getComponent(\"batBox_basic\").box_current == 0) {\n\t\t\t//------------------------------防止重复加载同一个格子高亮导致出现异常bug情况\n\t\t\ttemp.getComponent(\"batBox_basic\").box_current = 1; //-------------------------------高亮选择到的格子\n\t\t\tvar item = cc.instantiate(this.icon_arrow);\n\t\t\ttemp.addChild(item);\n\t\t\titem.setPosition(boxItem.x, boxItem.y);\n\t\t\titem.name = \"currentBox\";\n\t\t}\n\t},\n\t//销毁高亮资源   (格子对象)\n\tcurrentBox_destroy: function currentBox_destroy(boxItem) {\n\t\tthis.batBox.getChildByName(\"batBox_y\" + boxItem.y + \"_x\" + boxItem.x).getComponent(\"batBox_basic\").box_current = 0; //----------------------清除高亮记录\n\t\tvar child = this.batBox.getChildByName(\"batBox_y\" + boxItem.y + \"_x\" + boxItem.x).getChildByName(\"currentBox\");\n\t\tif (child) {\n\t\t\tchild.destroy();\n\t\t} //--------------------------------------------------------------销毁高亮资源\n\t},\n\t//障碍物具体参数数组   (障碍物编号，格子对象)\n\tbattleInit_obstacle_detail: function battleInit_obstacle_detail(point, box) {\n\t\tif (point == 1) {\n\t\t\tvar item = cc.instantiate(this.Prefab_obstacle_01);\n\t\t}\n\t\tif (point == 2) {\n\t\t\tvar item = cc.instantiate(this.Prefab_obstacle_02);\n\t\t}\n\t\tif (point == 3) {\n\t\t\tvar item = cc.instantiate(this.Prefab_obstacle_03);\n\t\t}\n\t\tthis.batBox.getChildByName(\"batBox_y\" + box.y + \"_x\" + box.x).addChild(item);\n\t\titem.setPosition(0, 0);\n\t\titem.name = \"point_\" + point;\n\t\tvar itemList = {\n\t\t\tx: box.x, //障碍物当前所处x轴\n\t\t\ty: box.y };\n\t\tthis.obstacle_list.push(itemList);\n\t},\n\t//英雄具体参数数组   (英雄编号，格子对象，敌我英雄标识id: 1=我方   2=敌方)\n\tbattleInit_hero_detail: function battleInit_hero_detail(point, box, groupId, personPrefabNew) {\n\t\tif (point == 1) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 2) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 3) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 4) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 5) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 6) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 7) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 8) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 9) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 10) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (point == 11) {\n\t\t\tvar item = this.perfabPool.createEnemy();\n\t\t}\n\t\tif (groupId == 1) {\n\t\t\tthis.other.addChild(item);\n\t\t}\n\t\tif (groupId == 2) {\n\t\t\tthis.enemy.addChild(item);\n\t\t}\n\t\tvar x = this.batBox.getChildByName(\"batBox_y\" + box.y + \"_x\" + box.x).x;\n\t\tvar y = this.batBox.getChildByName(\"batBox_y\" + box.y + \"_x\" + box.x).y;\n\t\titem.setPosition(x, y);\n\t\titem.name = \"hero_\" + point;\n\t\tif (groupId == 1) {\n\t\t\tvar hero_basic = this.other.getChildByName(item.name).getComponent(\"person\");\n\t\t\thero_basic.groupId = groupId;\n\t\t\thero_basic.heroName = item.name;\n\t\t\thero_basic.x = box.x;\n\t\t\thero_basic.y = box.y;\n\t\t\thero_basic.point = point;\n\t\t}\n\t\tvar itemList = {\n\t\t\tgroupId: groupId, //英雄敌我阵容标识\n\t\t\theroName: item.name, //英雄预存资源生成名称\n\t\t\tx: box.x, //英雄当前所处x轴\n\t\t\ty: box.y, //英雄当前所处y轴\n\t\t\tpoint: point, //英雄标记  纪录具体是哪个英雄\n\t\t\troute: [], //英雄移动路线   状态切换为移动时，赋值路线\n\t\t\tstate: 10 //英雄状态   10：静止，11：移动\n\t\t};\n\t\tthis.hero_list.push(itemList);\n\t\tvar self = this;\n\t\tvar heroRouteOkList = this.hero_route_ok_list;\n\t\tvar lastRouteTarget = null; //-------------------用作碰触到障碍物后保留前一个格子对象\n\t\tif (groupId == 1) {\n\t\t\tthis.other.getChildByName(\"hero_\" + point).on(cc.Node.EventType.TOUCH_START, function (event) {\n\t\t\t\tvar selfItem = this;\n\t\t\t\tvar self_x = event.getLocation().x;\n\t\t\t\tvar self_y = event.getLocation().y;\n\t\t\t\tif (self.background.getChildByName(\"tempColl_touch\")) {\n\t\t\t\t\tself.background.getChildByName(\"tempColl_touch\").destroy();\n\t\t\t\t} //--------销毁之前生成的临时路线碰触点 \n\t\t\t\t//---生成临时路线碰触点   如果不重新生成，会出现触碰点一直碰着相同格子没反应的问题，例如不断触碰起点，碰撞系统好像如果不离开碰触体，就不会重新算碰撞到\n\t\t\t\tvar tempColl_touch = cc.instantiate(self.Prefab_tempColl_touch);\n\t\t\t\tself.background.addChild(tempColl_touch);\n\t\t\t\ttempColl_touch.setPosition(self_x, self_y);\n\t\t\t\tself.background.getChildByName(\"tempColl_touch\").getComponent(\"colliderListener\").boxItem = null; //---初始化碰撞点上的格子对象\n\t\t\t});\n\t\t\tthis.other.getChildByName(\"hero_\" + point).on(cc.Node.EventType.TOUCH_MOVE, function (event) {\n\t\t\t\tvar selfItem = this;\n\t\t\t\tvar self_x = event.getLocation().x;\n\t\t\t\tvar self_y = event.getLocation().y;\n\t\t\t\tself.background.getChildByName(\"tempColl_touch\").x = self_x; //-------实时更改临时路线碰触点位置\n\t\t\t\tself.background.getChildByName(\"tempColl_touch\").y = self_y;\n\t\t\t\tvar isCenter = 0;\n\t\t\t\tvar boxItem = self.background.getChildByName(\"tempColl_touch\").getComponent(\"colliderListener\").boxItem;\n\t\t\t\tif (boxItem) {\n\t\t\t\t\tif (boxItem.name == \"batBox_Center\") {\n\t\t\t\t\t\tboxItem = boxItem.parent.getComponent(\"batBox_basic\");\n\t\t\t\t\t\tisCenter = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tboxItem = boxItem.getComponent(\"batBox_basic\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!boxItem.bat_obstacle) {\n\t\t\t\t\t\tif (heroRouteOkList.lastId == -1) {\n\t\t\t\t\t\t\t//--------------------------------还没记录到上一次的格子名字，证明是在获取第一次路线信息\n\t\t\t\t\t\t\tfor (var i = 0; i < self.hero_list.length; i++) {\n\t\t\t\t\t\t\t\t//------------循环英雄数组\n\t\t\t\t\t\t\t\tif (self.hero_list[i].heroName == selfItem.name) {\n\t\t\t\t\t\t\t\t\t//----------匹配当前点击的格子上是否存在英雄\n\t\t\t\t\t\t\t\t\tself.matchOKHeroRoute(selfItem.name, boxItem); //-------传参英雄名和格子对象给确认数组\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (isCenter == 1) {\n\t\t\t\t\t\t\t\tif (heroRouteOkList.lastId != boxItem.batBoxName) {\n\t\t\t\t\t\t\t\t\t//----------当前触碰的格子不是上一次记录的格子（此判断为了防止不断触碰相同格子一直执行以下方法）\n\t\t\t\t\t\t\t\t\tself.matchOKHeroRoute(heroRouteOkList.name, boxItem); //-------传参英雄名和格子对象给确认数组\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.other.getChildByName(\"hero_\" + point).on(cc.Node.EventType.TOUCH_CANCEL, function (event) {\n\t\t\t\tvar self_x = event.getLocation().x;\n\t\t\t\tvar self_y = event.getLocation().y;\n\t\t\t\tconsole.log(heroRouteOkList.list, self.hero_list);\n\t\t\t\tvar boxItem = self.background.getChildByName(\"tempColl_touch\").getComponent(\"colliderListener\").boxItem;\n\t\t\t\tif (boxItem.name == \"batBox_Center\") {\n\t\t\t\t\tboxItem = boxItem.parent.getComponent(\"batBox_basic\");\n\t\t\t\t} else {\n\t\t\t\t\tboxItem = boxItem.getComponent(\"batBox_basic\");\n\t\t\t\t}\n\t\t\t\tself.matchOKHeroRoute(heroRouteOkList.name, boxItem); //-------传参英雄名和格子对象给确认数组\n\t\t\t\tself.touchStop();\n\t\t\t});\n\t\t\tthis.other.getChildByName(\"hero_\" + point).on(cc.Node.EventType.TOUCH_END, function (event) {\n\t\t\t\tvar self_x = event.getLocation().x;\n\t\t\t\tvar self_y = event.getLocation().y;\n\t\t\t\tvar boxItem = self.background.getChildByName(\"tempColl_touch\").getComponent(\"colliderListener\").boxItem;\n\t\t\t\tif (boxItem.name == \"batBox_Center\") {\n\t\t\t\t\tboxItem = boxItem.parent.getComponent(\"batBox_basic\");\n\t\t\t\t} else {\n\t\t\t\t\tboxItem = boxItem.getComponent(\"batBox_basic\");\n\t\t\t\t}\n\t\t\t\tself.matchOKHeroRoute(heroRouteOkList.name, boxItem); //-------传参英雄名和格子对象给确认数组\n\t\t\t\tself.touchStop();\n\t\t\t});\n\t\t}\n\t},\n\t//鼠标或手指碰触结束   (路线确认数组)\n\ttouchStop: function touchStop() {\n\t\tvar self = this;\n\t\tvar heroRouteOkList = this.hero_route_ok_list;\n\t\tfor (var z = 0; z < heroRouteOkList.list.length; z++) {\n\t\t\tself.currentBox_destroy(heroRouteOkList.list[z]); //--------------------------销毁高亮资源方法\n\t\t}\n\t\tif (heroRouteOkList.list.length != 0) {\n\t\t\tvar heroList = self.hero_list.length;\n\t\t\tfor (var j = 0; j < heroList; j++) {\n\t\t\t\t//---------匹配英雄表\n\t\t\t\tif (self.hero_list[j].heroName == heroRouteOkList.name) {\n\t\t\t\t\t(function () {\n\t\t\t\t\t\t//--------------找出赋值英雄移动数组\n\t\t\t\t\t\tself.hero_list[j].state = 11; //----------------------------------------英雄状态切换为：移动\n\t\t\t\t\t\tself.hero_list[j].route = heroRouteOkList.list; //--------------赋值路线\n\t\t\t\t\t\tvar heroName = self.hero_list[j].heroName;\n\t\t\t\t\t\tvar heroItem = self.hero_list[j];\n\t\t\t\t\t\tvar routeList = self.hero_list[j].route;\n\t\t\t\t\t\theroRouteOkList.list = []; //---------------------------临时路线清空\n\t\t\t\t\t\theroRouteOkList.state = 0; //---------------------------临时路线状态改为不启用\n\t\t\t\t\t\theroRouteOkList.name = null; //-------------------------临时路线的英雄名清除\n\t\t\t\t\t\theroItem.state = 10; //--------------------------------------英雄状态改为静止\n\t\t\t\t\t\theroItem.route = null; //------------------------------------英雄的路线记录清空\n\t\t\t\t\t\theroRouteOkList.lastId = -1;\n\t\t\t\t\t\tvar num = 0; //-------------------------------------------------------------------临时值，作用累似for循环的i\n\t\t\t\t\t\tvar time = setInterval(function () {\n\t\t\t\t\t\t\tvar targetBoxItem = self.batBox.getChildByName(\"batBox_y\" + routeList[num].y + \"_x\" + routeList[num].x);\n\t\t\t\t\t\t\tvar end = cc.v2(targetBoxItem.x, targetBoxItem.y); //------------------------获取下个目标xy\n\t\t\t\t\t\t\tvar start = self.other.getChildByName(heroName).position; //-------------获取目标当前xy\n\t\t\t\t\t\t\tvar direction = cc.pNormalize(cc.pSub(end, start)); //------------------------先获取俩个向量的差，然后返回一个长度为1的标准化后的向量\n\t\t\t\t\t\t\tvar item = cc.pAdd(start, cc.pMult(direction, self.followSpeed * 0.4)); //----缩放上面的标准化向量，然后把初始目标xy加上缩放的向量\n\t\t\t\t\t\t\tself.other.getChildByName(heroName).setPosition(item); //----------------更新目标位置\n\t\t\t\t\t\t\tvar sum = cc.pDistance(start, end);\n\t\t\t\t\t\t\tif (sum <= 1 && num < routeList.length) {\n\t\t\t\t\t\t\t\t//-----------------向量测出英雄和下一个格子中心在1范围内就进入下一个路线\n\t\t\t\t\t\t\t\theroItem.x = targetBoxItem.getComponent(\"batBox_basic\").x; //----------------------------------------英雄当前x轴修改\n\t\t\t\t\t\t\t\theroItem.y = targetBoxItem.getComponent(\"batBox_basic\").y; //----------------------------------------英雄当前y轴修改\n\t\t\t\t\t\t\t\tjs_dataControl.updateHeroList(self.hero_list); //----------------更新存储数据层js的英雄详细数组\n\t\t\t\t\t\t\t\t//英雄路线移动完毕后执行以下方法\n\t\t\t\t\t\t\t\tif (num + 1 == routeList.length) {\n\t\t\t\t\t\t\t\t\tself.batBox.getChildByName(\"batBox_y\" + routeList[num].y + \"_x\" + routeList[num].x).bat_hero = heroItem.point; //------------------------更改第一层战场格子上的英雄标记\n\t\t\t\t\t\t\t\t\tclearInterval(time);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tself.batBox.getChildByName(\"batBox_y\" + routeList[num].y + \"_x\" + routeList[num].x).bat_hero = heroItem.point; //------------------------更改第一层战场格子上的英雄标记\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, self.followSpeed * 0.4);\n\t\t\t\t\t})();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t//检测触碰到的英雄-确认   (英雄名,格子对象)\n\tmatchOKHeroRoute: function matchOKHeroRoute(heroName, boxItem) {\n\t\tvar heroRouteOkList = this.hero_route_ok_list;\n\t\theroRouteOkList.state = 1; //----------------------------------临时路线记录数组启用\n\t\theroRouteOkList.name = heroName; //----------------------------临时路线数组，记录英雄标识\n\t\theroRouteOkList.lastId = boxItem.batBoxName; //----------------赋值当前格子的名字\n\t\tif (heroRouteOkList.list.length == 0) {\n\t\t\t//-----------------------------已选格子不再执行以下方法\n\t\t\tvar item = {\n\t\t\t\tx: boxItem.x,\n\t\t\t\ty: boxItem.y\n\t\t\t};\n\t\t\theroRouteOkList.list.push(item);\n\t\t\tthis.currentBox(boxItem);\n\t\t} else {\n\t\t\tvar z = -1; //--------------获取确认数组的最后一个格子id\n\t\t\t//---获取A*填充数组，条件是当前确认数组最后一个格子对象和最新所选到的格子对象，用作处理可能越几格的路线填充\n\t\t\tvar checkRoute = this.routeDirection(heroRouteOkList.list[heroRouteOkList.list.length - 1], boxItem);\n\t\t\tif (checkRoute) {\n\t\t\t\tcheckRoute.splice(0, 1);\n\t\t\t} //-----------清空A*返回的路线数组的第一个格子路线，因为会和旧路线最后一个格子重复了\n\t\t\tconsole.log(checkRoute, heroRouteOkList.list);\n\t\t\tvar repeatList = []; //-----------------存储A*填充数组里和当前确认数组重复的格子对象，用作出现路线重复回滚\n\t\t\tvar noRepeatList = []; //---------------存储A*填充数组里不和当前确认数组不重复的格子对象，用作出现路线重复回滚时，可以继续填充路线\n\t\t\tvar ok_list = []; //--------------------临时存储确认数组的list\n\t\t\tvar repeatIndex = -1; //----------------记录A*填充数组最后一个格子下标   -1:初始   \n\t\t\tvar repeatIndexItem = null; //----------记录A*填充数组最后一个格子对象   -1:初始   \n\t\t\tvar noRepeatIndex = -1; //--------------记录A*填充数组最后一个格子下标   -1:初始   \n\t\t\tvar noRepeatIndexItem = null; //--------记录A*填充数组最后一个格子对象   -1:初始   \n\t\t\tfor (var i = 0; i < checkRoute.length; i++) {\n\t\t\t\tfor (var j = 0; j < heroRouteOkList.list.length; j++) {\n\t\t\t\t\tif (heroRouteOkList.list[j].x == checkRoute[i].x && heroRouteOkList.list[j].y == checkRoute[i].y) {\n\t\t\t\t\t\trepeatList.push(checkRoute[i]);\n\t\t\t\t\t\tcheckRoute[i].repeat = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theroRouteOkList.list.push(checkRoute[i]);\n\t\t\t\tthis.currentBox(this.batBox.getChildByName(\"batBox_y\" + checkRoute[i].y + \"_x\" + checkRoute[i].x).getComponent(\"batBox_basic\"));\n\t\t\t}\n\t\t\tif (repeatList.length > 0) {\n\t\t\t\t//-----------A*填充数组存在2个值时代表越墙或者终点不只在起点九宫格\n\t\t\t\tfor (var x = 0; x < heroRouteOkList.list.length; x++) {\n\t\t\t\t\tif (repeatIndex == -1) {\n\t\t\t\t\t\t//-----------------标识不存在时\n\t\t\t\t\t\tif (repeatList[repeatList.length - 1].x == heroRouteOkList.list[x].x && repeatList[repeatList.length - 1].y == heroRouteOkList.list[x].y) {\n\t\t\t\t\t\t\t//------当前格子id等于确认数组id时\n\t\t\t\t\t\t\trepeatIndex = x; //-----------------赋值标识为当前循环下标\n\t\t\t\t\t\t\trepeatIndexItem = this.batBox.getChildByName(\"batBox_y\" + heroRouteOkList.list[x].y + \"_x\" + heroRouteOkList.list[x].x).getComponent(\"batBox_basic\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar temp_okItem = this.batBox.getChildByName(\"batBox_y\" + heroRouteOkList.list[x].y + \"_x\" + heroRouteOkList.list[x].x).getComponent(\"batBox_basic\").batBoxName;\n\t\t\t\t\t\t//console.log(temp_boxIndexItem , temp_okItem);\n\t\t\t\t\t\tif (repeatIndexItem.batBoxName != temp_okItem) {\n\t\t\t\t\t\t\tthis.currentBox_destroy(heroRouteOkList.list[x]); //--------------------------销毁高亮资源方法\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var o = 0; o < repeatIndex + 1; o++) {\n\t\t\t\t\t//---循环不重复的下标+1的次数来获取确认数组路线\n\t\t\t\t\tvar _item = {\n\t\t\t\t\t\tx: heroRouteOkList.list[o].x,\n\t\t\t\t\t\ty: heroRouteOkList.list[o].y\n\t\t\t\t\t};\n\t\t\t\t\tok_list.push(_item);\n\t\t\t\t}\n\t\t\t\theroRouteOkList.list = ok_list;\n\t\t\t\tfor (var _i3 = 0; _i3 < checkRoute.length; _i3++) {\n\t\t\t\t\tif (repeatIndexItem.x == checkRoute[_i3].x && repeatIndexItem.y == checkRoute[_i3].y) {\n\t\t\t\t\t\tnoRepeatIndex = 1; //-----------------判断到最新的A*填充数组里有重复值时记录当前值下标\n\t\t\t\t\t}\n\t\t\t\t\tif (noRepeatIndex == 1) {\n\t\t\t\t\t\t//--------------当有重复后，回滚到重复的格子处，后续的路线继续加入路线中\n\t\t\t\t\t\tvar _item2 = {\n\t\t\t\t\t\t\tx: checkRoute[_i3].x,\n\t\t\t\t\t\t\ty: checkRoute[_i3].y\n\t\t\t\t\t\t};\n\t\t\t\t\t\theroRouteOkList.list.push(_item2);\n\t\t\t\t\t\tthis.currentBox(this.batBox.getChildByName(\"batBox_y\" + checkRoute[_i3].y + \"_x\" + checkRoute[_i3].x).getComponent(\"batBox_basic\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(noRepeatList, repeatList);\n\t\t\t}\n\t\t}\n\t\t//console.log(heroRouteOkList.list);\n\t},\n\t//A*算法   (原点目标，终点目标)\n\trouteDirection: function routeDirection(startTarget, endTarget) {\n\t\tif (startTarget.x == endTarget.x && startTarget.y == endTarget.y) {\n\t\t\treturn false;\n\t\t} //---------------如果起点和终点一样就退出方法\n\t\tvar openList = []; //---------------九宫格临时存放格子数组\n\t\tvar closeList = []; //--------------九宫格临时存放确认数组\n\t\tvar sureList = []; //---------------九宫格最终确认数组\n\t\tvar isSure_start = 0; //------------是否到达终点   0：不是   1：是\n\t\tvar isSure_end = 0; //--------------是否到达起点   0：不是   1：是\n\t\tvar minF = 0; //--------------------F值最小值\n\t\tvar minG = 0; //--------------------G值最小值\n\t\tvar parent = { x: startTarget.x, y: startTarget.y, isStart: 1, G: 0, H: 0, F: 0 }; //-----------isStart: 起点的唯一标识\n\t\topenList.push(parent);\n\t\t//方向数组  也可用作判断格子九宫格里其余格子是否在战场内数组   id：判断方向的数值   direction：上下左右斜方向值\n\t\tvar directionList = [{ y: 0, x: 1, direction: 1 }, { y: -1, x: 1, direction: 2 }, { y: -1, x: 0, direction: 3 }, { y: -1, x: -1, direction: 4 }, { y: 0, x: -1, direction: 5 }, { y: 1, x: -1, direction: 6 }, { y: 1, x: 0, direction: 7 }, { y: 1, x: 1, direction: 8 }];\n\t\tthis.batBox.getChildByName(\"batBox_y\" + startTarget.y + \"_x\" + startTarget.x).setColor(cc.color(\"#008102\")); //-----测试阶段，上颜色标识用\n\t\tthis.batBox.getChildByName(\"batBox_y\" + endTarget.y + \"_x\" + endTarget.x).setColor(cc.color(\"#fff\")); //-----测试阶段，上颜色标识用\n\t\tvar tempEndTarget = this.batBox.getChildByName(\"batBox_y\" + endTarget.y + \"_x\" + endTarget.x).getComponent(\"batBox_basic\");\n\t\tfor (var j = 0; j < openList.length; j++) {\n\t\t\tif (isSure_start == 1) {\n\t\t\t\tbreak;\n\t\t\t} //----------已到达终点，退出循环\n\t\t\t//console.log(j+\"——————————————————————————————————————————————————\");\n\t\t\t//console.log(parent,openList[j]);\n\t\t\tvar obsExList = []; //--------------障碍物上下左右格子的数组\n\t\t\tvar obsId_right = null; //----------当前障碍物格子的右侧格子--临时禁止加入临时数组\n\t\t\tvar obsId_down = null; //-----------当前障碍物格子的下侧格子--临时禁止加入临时数组\n\t\t\tvar obsId_left = null; //-----------当前障碍物格子的左侧格子--临时禁止加入临时数组\n\t\t\tvar obsId_top = null; //------------当前障碍物格子的上侧格子--临时禁止加入临时数组\n\t\t\tfor (var i = 0; i < directionList.length; i++) {\n\t\t\t\t//------------------获取路线障碍物上下左右格子的数组\n\t\t\t\t//计算出九宫格内当前循环的格子是否在战场内  原理：利用格子的行列值进行运算，得出结果异常则不属于战场内格子\n\t\t\t\tvar tempCheckTarget = this.batBox.getChildByName(\"batBox_y\" + (parent.y + directionList[i].y) + \"_x\" + (parent.x + directionList[i].x));\n\t\t\t\tif (tempCheckTarget) {\n\t\t\t\t\t//----------是否存在格子\n\t\t\t\t\tvar checkTarget = tempCheckTarget.getComponent(\"batBox_basic\");\n\t\t\t\t\tif (checkTarget.bat_obstacle) {\n\t\t\t\t\t\t//---------------------当前循环九宫格格子是障碍物\n\t\t\t\t\t\tif (i == 0 || i == 2 || i == 4 || i == 6) {\n\t\t\t\t\t\t\tobsId_right = { y: checkTarget.y + directionList[0].y, x: checkTarget.x + directionList[0].x };\n\t\t\t\t\t\t\tobsId_down = { y: checkTarget.y + directionList[2].y, x: checkTarget.x + directionList[2].x };\n\t\t\t\t\t\t\tobsId_left = { y: checkTarget.y + directionList[4].y, x: checkTarget.x + directionList[4].x };\n\t\t\t\t\t\t\tobsId_top = { y: checkTarget.y + directionList[6].y, x: checkTarget.x + directionList[6].x };\n\t\t\t\t\t\t\tobsExList.push(obsId_right, obsId_down, obsId_left, obsId_top);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var _i4 = 0; _i4 < directionList.length; _i4++) {\n\t\t\t\t//------------------获取路线临时数组\n\t\t\t\tvar isOpen = 0; //------------------是否已记录在临时数组标识   0：不是   1：是\n\t\t\t\tvar isClose = 0; //-----------------是否已记录在确认数组标识   0：不是   1：是\n\t\t\t\tvar isObstacle = 0; //--------------是否障碍物   0：不是   1：是\n\t\t\t\tvar isObsEx = 0; //-----------------当前格子是否位于障碍物格子上下左右侧的格子位置上，用于判断是否处于斜格处理   0：不是   1：是\n\t\t\t\t//计算出九宫格内当前循环的格子  原理：利用格子的行列值进行运算，得出结果异常则不属于战场内格子\n\t\t\t\tvar _tempCheckTarget = this.batBox.getChildByName(\"batBox_y\" + (parent.y + directionList[_i4].y) + \"_x\" + (parent.x + directionList[_i4].x));\n\t\t\t\tif (_tempCheckTarget) {\n\t\t\t\t\t//----------是否存在格子\n\t\t\t\t\tvar checkTarget = _tempCheckTarget.getComponent(\"batBox_basic\");\n\t\t\t\t\tif (checkTarget.bat_obstacle) {\n\t\t\t\t\t\t//---------------------当前循环九宫格格子是障碍物\n\t\t\t\t\t\tisObstacle = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var x = 0; x < closeList.length; x++) {\n\t\t\t\t\t\t\t//------------------当前循环九宫格格子是否已记录在确认数组\n\t\t\t\t\t\t\tif (checkTarget.x == closeList[x].x && checkTarget.y == closeList[x].y) {\n\t\t\t\t\t\t\t\tisClose = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var _x = 0; _x < openList.length; _x++) {\n\t\t\t\t\t\t\t//-------------------当前循环九宫格格子是否已记录在临时数组\n\t\t\t\t\t\t\tif (checkTarget.x == openList[_x].x && checkTarget.y == openList[_x].y) {\n\t\t\t\t\t\t\t\tisOpen = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var o = 0; o < obsExList.length; o++) {\n\t\t\t\t\t\t\t//------------------当前循环九宫格格子是否位于障碍物格子上下左右侧的格子位置上，是的话就不能纳入赋值ghf处理\n\t\t\t\t\t\t\tif (checkTarget.x == obsExList[o].x && checkTarget.y == obsExList[o].y) {\n\t\t\t\t\t\t\t\tisObsEx = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isClose == 0 && isOpen == 0 && isObstacle == 0 && isObsEx == 0) {\n\t\t\t\t\t\t//-------------如任何检查判断为未触发，则视为当前格子是新处理格子\n\t\t\t\t\t\tvar H_x = Math.abs(tempEndTarget.x - checkTarget.x);\n\t\t\t\t\t\tvar H_y = Math.abs(tempEndTarget.y - checkTarget.y);\n\t\t\t\t\t\tvar H = (H_x + H_y) * 10;\n\t\t\t\t\t\tvar G = void 0;\n\n\t\t\t\t\t\tif (_i4 == 0 || _i4 == 2 || _i4 == 4 || _i4 == 6) {\n\t\t\t\t\t\t\tG = 10 + parent.G;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tG = 14 + parent.G;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar item = {\n\t\t\t\t\t\t\tx: checkTarget.x,\n\t\t\t\t\t\t\ty: checkTarget.y,\n\t\t\t\t\t\t\tG: G, //--------------------------------从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。\n\t\t\t\t\t\t\tH: H, //--------------------------------从指定的方格移动到终点 B 的估算成本\n\t\t\t\t\t\t\tF: G + H,\n\t\t\t\t\t\t\tdirection: directionList[_i4].direction\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar label_G = new cc.Node();\n\t\t\t\t\t\tlabel_G.addComponent(cc.Label);\n\t\t\t\t\t\tlabel_G.getComponent(cc.Label).fontSize = 12;\n\t\t\t\t\t\tlabel_G.getComponent(cc.Label).string = checkTarget.y + \"\" + checkTarget.x + \"，F：\" + (G + H) + \"\\nG:\" + G + \"，H:\" + H;\n\t\t\t\t\t\t_tempCheckTarget.addChild(label_G);\n\t\t\t\t\t\topenList.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (openList[0].isStart == 1) {\n\t\t\t\t//-----------处理起点的首次增删数组操作\n\t\t\t\tcloseList.push(openList[0]);\n\t\t\t\topenList.splice(0, 1);\n\t\t\t\tj = -1; //-------------------------------初始化循环次数\n\t\t\t}\n\t\t\tfor (var _i5 = 0; _i5 < openList.length; _i5++) {\n\t\t\t\t//----------循环取F值最小值\n\t\t\t\tif (openList[_i5] && minF == 0) {\n\t\t\t\t\t//------------------------为了排除可能会遇到没F值的父格子，当存在的F值的循环才初始化\n\t\t\t\t\tminF = openList[_i5];\n\t\t\t\t}\n\t\t\t\tif (minF.F > openList[_i5].F) {\n\t\t\t\t\tminF = openList[_i5];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var _i6 = 0; _i6 < openList.length; _i6++) {\n\t\t\t\t//----------依靠最新的F值最小值格子得出新的父节点\n\t\t\t\tif (openList[_i6].F == minF.F) {\n\t\t\t\t\tparent = openList[_i6];\n\t\t\t\t\tcloseList.push(openList[_i6]);\n\t\t\t\t\topenList.splice(_i6, 1);\n\t\t\t\t\tj = -1; //-------------------------------初始化循环次数\n\t\t\t\t\tminF = 0; //-----------初始化F值最小值\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parent.x == tempEndTarget.x && parent.y == tempEndTarget.y) {\n\t\t\t\t//---------------如果临时确认数组收录了终点，就退出循环\n\t\t\t\tisSure_start = 1;\n\t\t\t}\n\t\t}\n\t\tfor (var _j3 = 0; _j3 < closeList.length; _j3++) {\n\t\t\tthis.batBox.getChildByName(\"batBox_y\" + closeList[_j3].y + \"_x\" + closeList[_j3].x).setColor(cc.color(\"#008102\")); //-----测试阶段，上颜色标识用\n\t\t}\n\t\tcloseList = closeList.reverse();\n\t\tsureList.push(parent);\n\t\t//计算最终路线    原理：从临时确认数组中反过来走到起点\n\t\tfor (var _j4 = 0; _j4 < closeList.length; _j4++) {\n\t\t\tif (isSure_end == 1) {\n\t\t\t\tbreak;\n\t\t\t} //----------已回到起点，退出循环\n\t\t\tvar _obsExList = []; //--------------障碍物上下左右格子的数组\n\t\t\tvar _obsId_right = null; //----------当前障碍物格子的右侧格子--临时禁止加入临时数组\n\t\t\tvar _obsId_down = null; //-----------当前障碍物格子的下侧格子--临时禁止加入临时数组\n\t\t\tvar _obsId_left = null; //-----------当前障碍物格子的左侧格子--临时禁止加入临时数组\n\t\t\tvar _obsId_top = null; //------------当前障碍物格子的上侧格子--临时禁止加入临时数组\n\t\t\tvar tempSureList = [];\n\t\t\tconsole.log(_j4 + \"——————————————————————————————————————————————————\");\n\t\t\tfor (var _i7 = 0; _i7 < directionList.length; _i7++) {\n\t\t\t\t//获取当前循环的父节点格子  \n\t\t\t\tvar _tempCheckTarget2 = this.batBox.getChildByName(\"batBox_y\" + (parent.y + directionList[_i7].y) + \"_x\" + (parent.x + directionList[_i7].x));\n\t\t\t\tif (_tempCheckTarget2) {\n\t\t\t\t\t//----------是否存在格子\n\t\t\t\t\tvar checkTarget = _tempCheckTarget2.getComponent(\"batBox_basic\");\n\t\t\t\t\tif (checkTarget.bat_obstacle) {\n\t\t\t\t\t\t//---------------------当前循环九宫格格子是障碍物\n\t\t\t\t\t\tif (_i7 == 0 || _i7 == 2 || _i7 == 4 || _i7 == 6) {\n\t\t\t\t\t\t\t_obsId_right = { y: checkTarget.y + directionList[0].y, x: checkTarget.x + directionList[0].x };\n\t\t\t\t\t\t\t_obsId_down = { y: checkTarget.y + directionList[2].y, x: checkTarget.x + directionList[2].x };\n\t\t\t\t\t\t\t_obsId_left = { y: checkTarget.y + directionList[4].y, x: checkTarget.x + directionList[4].x };\n\t\t\t\t\t\t\t_obsId_top = { y: checkTarget.y + directionList[6].y, x: checkTarget.x + directionList[6].x };\n\t\t\t\t\t\t\t_obsExList.push(_obsId_right, _obsId_down, _obsId_left, _obsId_top);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var _i8 = 0; _i8 < directionList.length; _i8++) {\n\t\t\t\tvar _isClose = 0; //-----------------是否已记录在确认数组标识   0：不是   1：是\n\t\t\t\tvar _isObstacle = 0; //--------------是否障碍物   0：不是   1：是\n\t\t\t\tvar _isObsEx = 0; //-----------------当前格子是否位于障碍物格子上下左右侧的格子位置上，用于判断是否处于斜格处理   0：不是   1：是\n\t\t\t\tvar _tempCheckTarget3 = this.batBox.getChildByName(\"batBox_y\" + (parent.y + directionList[_i8].y) + \"_x\" + (parent.x + directionList[_i8].x));\n\t\t\t\tif (_tempCheckTarget3) {\n\t\t\t\t\t//----------是否存在格子\n\t\t\t\t\tvar checkTarget = _tempCheckTarget3.getComponent(\"batBox_basic\");\n\t\t\t\t\tif (checkTarget.bat_obstacle) {\n\t\t\t\t\t\t//---------------------当前循环九宫格格子是障碍物\n\t\t\t\t\t\t_isObstacle = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var _x2 = 0; _x2 < closeList.length; _x2++) {\n\t\t\t\t\t\t\t//------------------当前循环九宫格格子是否已记录在确认数组\n\t\t\t\t\t\t\tif (checkTarget.x == closeList[_x2].x && checkTarget.y == closeList[_x2].y) {\n\t\t\t\t\t\t\t\tfor (var _o = 0; _o < _obsExList.length; _o++) {\n\t\t\t\t\t\t\t\t\t//------------------当前循环九宫格格子是否位于障碍物格子上下左右侧的格子位置上，是的话就不能纳入赋值ghf处理\n\t\t\t\t\t\t\t\t\tif (checkTarget.x == _obsExList[_o].x && checkTarget.y == _obsExList[_o].y) {\n\t\t\t\t\t\t\t\t\t\t_isObsEx = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_isObsEx == 0) {\n\t\t\t\t\t\t\t\t\ttempSureList.push(closeList[_x2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var _i9 = 0; _i9 < tempSureList.length; _i9++) {\n\t\t\t\t//----------循环取F值最小值\n\t\t\t\tif (tempSureList[_i9] && minG == 0) {\n\t\t\t\t\t//------------------------为了排除可能会遇到没G值的父格子，当存在的G值的循环才初始化\n\t\t\t\t\tminG = tempSureList[_i9];\n\t\t\t\t}\n\t\t\t\tif (minG.G > tempSureList[_i9].G) {\n\t\t\t\t\tminG = tempSureList[_i9];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var _i10 = 0; _i10 < tempSureList.length; _i10++) {\n\t\t\t\t//----------依靠最新的G值最小值格子得出新的父节点\n\t\t\t\tif (tempSureList[_i10].G == minG.G) {\n\t\t\t\t\tparent = tempSureList[_i10];\n\t\t\t\t\tsureList.push(tempSureList[_i10]);\n\t\t\t\t\tminG = 0; //-----------初始化G值最小值\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parent.x == startTarget.x && parent.y == startTarget.y) {\n\t\t\t\t//---------------如果临时确认数组收录了起点，就退出循环\n\t\t\t\tisSure_end = 1;\n\t\t\t}\n\t\t}\n\t\tfor (var _j5 = 0; _j5 < sureList.length; _j5++) {\n\t\t\tthis.batBox.getChildByName(\"batBox_y\" + sureList[_j5].y + \"_x\" + sureList[_j5].x).setColor(cc.color(\"#bbb\")); //-----测试阶段，上颜色标识用\n\t\t}\n\t\t//console.log(sureList,closeList);\n\t\treturn sureList.reverse();\n\t},\n\t//获取最近敌人\n\tgetNearEnemy: function getNearEnemy(target, dataList) {\n\t\tvar tempList = [];\n\t\tvar enemyList = [];\n\t\tvar minF = 0;\n\t\tfor (var i = 0; i < dataList.length; i++) {\n\t\t\tif (dataList[i].groupId == 2) {\n\t\t\t\tvar H_x = Math.abs(dataList[i].x - target.x);\n\t\t\t\tvar H_y = Math.abs(dataList[i].y - target.y);\n\t\t\t\tvar H = (H_x + H_y) * 10;\n\t\t\t\tvar G = 0;\n\t\t\t\tvar item = {\n\t\t\t\t\tx: dataList[i].x,\n\t\t\t\t\ty: dataList[i].y,\n\t\t\t\t\tG: G, //--------------------------------从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。\n\t\t\t\t\tH: H, //--------------------------------从指定的方格移动到终点 B 的估算成本\n\t\t\t\t\tF: G + H\n\t\t\t\t};\n\t\t\t\ttempList.push(item);\n\t\t\t\tenemyList.push(dataList[i]);\n\t\t\t}\n\t\t}\n\t\tfor (var _i11 = 0; _i11 < tempList.length; _i11++) {\n\t\t\tif (tempList[_i11].F && minF == 0) {\n\t\t\t\t//------------------------为了排除可能会遇到没F值的父格子，当存在的F值的循环才初始化\n\t\t\t\tminF = tempList[_i11];\n\t\t\t}\n\t\t\tif (minF.F > tempList[_i11].F) {\n\t\t\t\tminF = tempList[_i11];\n\t\t\t}\n\t\t}\n\t\treturn minF;\n\t}\n});\n\ncc._RF.pop();","deps":{"dataControl":"/Users/joker/Desktop/demo/NewProject/library/imports/53/53073d40-572b-47eb-93ec-d446b3b3dec0.js"}}},"packageCache":{"/Users/joker/Desktop/demo/NewProject/assets/test 2/js/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test 2/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/package.json":false,"/Users/joker/Desktop/demo/NewProject/package.json":false,"/Users/joker/Desktop/demo/package.json":false,"/Users/joker/Desktop/package.json":false,"/Users/joker/package.json":false,"/Users/package.json":false,"/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test 2/js/character.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test 2/js/pkLoad.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test 2/js/test.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/05/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/79/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/21/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/21/21e43594-f3e1-4850-88fe-6a4bf97a5bb5.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/21"},"/Users/joker/Desktop/demo/NewProject/library/imports/05/059619d9-d846-4444-bd0f-85d613da4c1b.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/05"},"/Users/joker/Desktop/demo/NewProject/library/imports/79/79f1b76b-694c-4d53-a911-018db2ddb276.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/79"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/character.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/pkLoad.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/test.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/move.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/ae/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/ae/aecd5776-0be7-4694-8f03-4fbf3e3d35d4.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/ae"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/ColliderListener.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/fd/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/fd/fd672d14-58f3-433e-8857-71b99b941d75.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/fd"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/NewScript.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/5b/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/5b/5bb65800-917f-4355-b645-9eea1c898d2a.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/5b"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/rangedMove.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/11/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/11/113e344f-026f-4af4-95fc-69a8499577ed.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/11"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/body.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/f9/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/f9/f985b451-943d-4a9d-95b6-9fc60bbc5235.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/f9"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/body2.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/test.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/31/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/31/314c10e2-39e8-4775-8089-137e7ac73c9f.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/31"},"/Users/joker/Desktop/demo/NewProject/library/imports/d4/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/d4/d442d0cc-1210-4809-9313-2ed9c94a0a31.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/d4"},"/Users/joker/Desktop/demo/NewProject/library/imports/c2/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/c2/c219ebfc-fb2f-44e5-8aa9-f2f2fb7cfe12.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/c2"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/animHelper.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/animHelper.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/body.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/NewScript.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/65/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/65/650da195-e044-4451-81d0-e65e8e042d3c.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/65"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/lifeBarHelper.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/lifeBar.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/anim.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/animation.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/test的副本.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/71/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/71/7132a33c-7175-4f4e-b9a9-41d23b1433fc.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/71"},"/Users/joker/Desktop/demo/NewProject/library/imports/7b/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/7b/7b18cae2-b268-4dca-ab87-725aa35dfc68.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/7b"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/findMn.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/findEnemy.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/29/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/29/29fb5e54-d47c-4b4f-8dc3-baca5c6f728f.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/29"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/person.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/findAtkTarget.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/HPBarHelper.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/attack.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/flyerMove.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/flyerMove.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/personNew.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/36/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/36/363c0fcc-fe71-4f00-8d09-d50ac32b5c8c.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/36"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/personNew.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/New/hpBarHelper.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/teamBuild.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/21/210fed25-15f2-4438-bf72-45abd19d702e.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/21"},"/Users/joker/Desktop/demo/NewProject/library/imports/75/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/75/757c4f18-2838-4e71-b0a2-78bd80e5163f.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/75"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/dataControl.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/53/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/53/53073d40-572b-47eb-93ec-d446b3b3dec0.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/53"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/batBox_data/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/batBox_data/batBox_basic.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/batBox_data/collTest.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/batBox_data/colliderListener.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/batBox_data/followMove.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/battle_Control.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/checkPointData.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/checkPoint_Control.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/hero_data/package.json":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/hero_data/hero_basic.js":false,"/Users/joker/Desktop/demo/NewProject/assets/test/js/teamBuild_Control.js":false,"/Users/joker/Desktop/demo/NewProject/library/imports/f3/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/f3/f3cdca6e-acfa-4db8-a234-94f9629da9f8.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/f3"},"/Users/joker/Desktop/demo/NewProject/library/imports/f3/f3f6d102-a1e5-43fb-bf70-b7f3dc048edb.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/f3"},"/Users/joker/Desktop/demo/NewProject/library/imports/f1/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/f1/f104f1cc-eca7-4ba0-8cb6-660d1cb7e794.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/f1"},"/Users/joker/Desktop/demo/NewProject/library/imports/59/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/59/593c0e1a-50e1-4c39-904f-89555ee2a593.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/59"},"/Users/joker/Desktop/demo/NewProject/library/imports/1a/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/1a/1ab86e0f-f9ca-4c44-aec6-a85c2e924880.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/1a"},"/Users/joker/Desktop/demo/NewProject/library/imports/e8/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/e8/e88e58c7-fdce-45aa-9c05-acae92c3e6f0.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/e8"},"/Users/joker/Desktop/demo/NewProject/library/imports/4b/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/4b/4b8fccb7-65d4-4f03-9b28-8532bf1ba8f6.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/4b"},"/Users/joker/Desktop/demo/NewProject/library/imports/2f/package.json":false,"/Users/joker/Desktop/demo/NewProject/library/imports/2f/2f3f0e1e-6074-4464-8a08-083e66045150.js":{"__dirname":"/Users/joker/Desktop/demo/NewProject/library/imports/2f"},"/Users/joker/Desktop/demo/NewProject/assets/test/js/prefabPool.js":false}}}