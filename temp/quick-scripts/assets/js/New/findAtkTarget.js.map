{"version":3,"sources":["findAtkTarget.js"],"names":["js_dataControl","require","AttackType","cc","Class","extends","Component","properties","onLoad","findCanAtkGrid","atkType","rowGrid","colGrid","atkDistMin","atkDistMax","canAtkGrids","position","Number","Range","top","bottom","left","right","push","toString","substring","i","topLeft","topRight","bottomLeft","bottomRight","findNew","getHeroList","length","canAtkTreget","gridList","grid","temp","groupId","isDie","boxId","y","x","j","atkTarget","Object","heroName","checkTargetInGrids","atkTargetName","atkTargetBoxId"],"mappings":"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","file":"findAtkTarget.js","sourceRoot":"..\\..\\..\\..\\..\\assets\\js\\New","sourcesContent":["//导入外部脚本\r\nvar js_dataControl = require(\"dataControl\");\r\nconst AttackType = require('Types').AttackType;\r\ncc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n\r\n    },\r\n\r\n    // use this for initialization\r\n    onLoad: function () {\r\n\r\n    },\r\n    //寻找最近的敌人（向量版）\r\n    // find: function (position, enemyCamp, atkDistMax) {\r\n    //     //key距离、value节点\r\n    //     var enemyMap = {};\r\n    //     var keyArray = new Array();\r\n    //     //循环查找目标\r\n    //     if (enemyCamp == null || enemyCamp.childrenCount == 0) {\r\n    //         return;\r\n    //     }\r\n    //     var enemys = enemyCamp.children;\r\n    //     for (var i = 0; i < enemys.length; i++) {\r\n    //         if (enemys[i] == null || enemys[i].getComponent('person').isDie()) {\r\n    //             continue;\r\n    //         }\r\n    //         var position = this.getTargetDistance(position, enemys[i]);\r\n    //         enemyMap[position] = enemys[i];\r\n    //         keyArray.push(position);\r\n    //     }\r\n    //     //冒泡排序，找到最近的目标\r\n    //     for (var i = 0; i < keyArray.length; i++) {\r\n    //         for (var j = i; j < keyArray.length; j++) {\r\n    //             if (keyArray[i] > keyArray[j]) {\r\n    //                 var key = keyArray[i];\r\n    //                 keyArray[i] = keyArray[j];\r\n    //                 keyArray[j] = key;\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     if (keyArray[0] <= atkDistMax) {\r\n    //         return enemyMap[keyArray[0]];\r\n    //     } else {\r\n    //         return null;\r\n    //     }\r\n    // },\r\n    // //获取距离\r\n    // getTargetDistance: function (position, atkTarget) {\r\n    //     if (atkTarget == null || atkTarget.getComponent('person').isDie()) {\r\n    //         return 9999;\r\n    //     }\r\n    //     return cc.pDistance(position, atkTarget.getPosition());\r\n    // },\r\n\r\n    //新寻敌、攻击方法（格子版）\r\n    findCanAtkGrid: function (atkType, rowGrid, colGrid, atkDistMin, atkDistMax) {\r\n        let canAtkGrids = [];\r\n        let position = Number(`${rowGrid}${colGrid}`);\r\n        //如果是远程，获取身边一个的攻击范围\r\n        if (AttackType.Range == atkType) {\r\n            let top = position + 10;\r\n            let bottom = position - 10;\r\n            let left = position - 1;\r\n            let right = position + 1;\r\n            if(top > 0 && top <= 50){\r\n                canAtkGrids.push(top);\r\n            }\r\n            if(bottom > 0 && bottom <= 50){\r\n                canAtkGrids.push(bottom);\r\n            }\r\n            if(left > 0 && left <= 50 && left.toString().substring(0,1) == rowGrid){\r\n                canAtkGrids.push(left);\r\n            }\r\n            if(right > 0 && right <= 50 && right.toString().substring(0,1) == rowGrid){\r\n                canAtkGrids.push(right);\r\n            }\r\n        }\r\n        //获取最小攻击范围到最大攻击范围的格子坐标\r\n        for (let i = atkDistMin; i <= atkDistMax; i++) {\r\n            var top = position + i * 10;\r\n            var bottom = position - i * 10;\r\n            var left = position - i;\r\n            var right = position + i;\r\n            if(top > 0 && top <= 50){\r\n                canAtkGrids.push(top);\r\n            }\r\n            if(bottom > 0 && bottom <= 50){\r\n                canAtkGrids.push(bottom);\r\n            }\r\n            if(left > 0 && left <= 50 && left.toString().substring(0,1) == rowGrid){\r\n                canAtkGrids.push(left);\r\n            }\r\n            if(right > 0 && right <= 50 && right.toString().substring(0,1) == rowGrid){\r\n                canAtkGrids.push(right);\r\n            }\r\n            //斜角\r\n            if(i < atkDistMax){\r\n                var topLeft = position + i * 11;\r\n                var topRight = position - i * 9;\r\n                var bottomLeft = position - i * 11;\r\n                var bottomRight = position + i * 9;\r\n                if(topLeft > 0 && topLeft <= 50){\r\n                    canAtkGrids.push(topLeft);\r\n                }\r\n                if(topRight > 0 && topRight <= 50){\r\n                    canAtkGrids.push(topRight);\r\n                }\r\n                if(bottomLeft > 0 && bottomLeft <= 50){\r\n                    canAtkGrids.push(bottomLeft);\r\n                }\r\n                if(bottomRight > 0 && bottomRight <= 50){\r\n                    canAtkGrids.push(bottomRight);\r\n                }\r\n            }\r\n        }\r\n        return canAtkGrids;\r\n    },\r\n    findNew: function(atkType, rowGrid, colGrid, atkDistMin, atkDistMax){\r\n        if(js_dataControl.getHeroList() && js_dataControl.getHeroList().length > 0){\r\n            let canAtkGrids = this.findCanAtkGrid(atkType, rowGrid, colGrid, atkDistMin, atkDistMax);\r\n            //cc.log(canAtkGrids);\r\n            let canAtkTreget = {};\r\n            let gridList = [];\r\n            for(let grid of canAtkGrids){\r\n                for(let temp of js_dataControl.getHeroList()){\r\n                    if(temp.groupId == 2 && temp.isDie == 1){\r\n                        let boxId = `${temp.y}${temp.x}`;\r\n                        //cc.log(boxId);\r\n                        if(grid == boxId){\r\n                            canAtkTreget[temp.boxId] = temp;\r\n                            gridList.push(temp.boxId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for(let i=0;i<gridList.length;i++){\r\n                for(let j=i;j<gridList.length;j++){\r\n                    if (gridList[i] > gridList[j]) {\r\n                        var temp = gridList[i];\r\n                        gridList[i] = gridList[j];\r\n                        gridList[j] = temp;\r\n                    }\r\n                }\r\n            }\r\n            let atkTarget = canAtkTreget[gridList[0]];\r\n            if(atkTarget && atkTarget instanceof Object){\r\n                return atkTarget.heroName;\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * 检测当前攻击目标是否还在攻击范围内\r\n     */\r\n    checkTargetInGrids:function(atkType, atkTargetName, rowGrid, colGrid, atkDistMin, atkDistMax){\r\n        for(let temp of js_dataControl.getHeroList()){\r\n            if(temp.heroName == atkTargetName){\r\n                let atkTargetBoxId = `${temp.y}${temp.x}`;\r\n                let canAtkGrids = this.findCanAtkGrid(atkType, rowGrid, colGrid, atkDistMin, atkDistMax);\r\n                for(let grid of canAtkGrids){\r\n                    if(atkTargetBoxId == grid){\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n});\r\n"]}