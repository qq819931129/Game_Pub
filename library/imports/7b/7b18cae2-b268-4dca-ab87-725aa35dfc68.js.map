{"version":3,"sources":["../../../../../assets/js/New/assets/js/New/findAtkTarget.js"],"names":["js_dataControl","require","AttackType","cc","Class","extends","Component","properties","onLoad","findCanAtkGrid","atkType","rowGrid","colGrid","atkDistMin","atkDistMax","canAtkGrids","position","Number","Range","top","bottom","left","right","push","toString","substring","i","topLeft","topRight","bottomLeft","bottomRight","findNew","getHeroList","length","canAtkTreget","gridList","grid","temp","groupId","isDie","boxId","y","x","j","atkTarget","Object","heroName","checkTargetInGrids","atkTargetName","atkTargetBoxId"],"mappings":"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","file":"findAtkTarget.js","sourceRoot":"../../../../../assets/js/New","sourcesContent":["//导入外部脚本\nvar js_dataControl = require(\"dataControl\");\nconst AttackType = require('Types').AttackType;\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n\n    },\n\n    // use this for initialization\n    onLoad: function () {\n\n    },\n    //寻找最近的敌人（向量版）\n    // find: function (position, enemyCamp, atkDistMax) {\n    //     //key距离、value节点\n    //     var enemyMap = {};\n    //     var keyArray = new Array();\n    //     //循环查找目标\n    //     if (enemyCamp == null || enemyCamp.childrenCount == 0) {\n    //         return;\n    //     }\n    //     var enemys = enemyCamp.children;\n    //     for (var i = 0; i < enemys.length; i++) {\n    //         if (enemys[i] == null || enemys[i].getComponent('person').isDie()) {\n    //             continue;\n    //         }\n    //         var position = this.getTargetDistance(position, enemys[i]);\n    //         enemyMap[position] = enemys[i];\n    //         keyArray.push(position);\n    //     }\n    //     //冒泡排序，找到最近的目标\n    //     for (var i = 0; i < keyArray.length; i++) {\n    //         for (var j = i; j < keyArray.length; j++) {\n    //             if (keyArray[i] > keyArray[j]) {\n    //                 var key = keyArray[i];\n    //                 keyArray[i] = keyArray[j];\n    //                 keyArray[j] = key;\n    //             }\n    //         }\n    //     }\n    //     if (keyArray[0] <= atkDistMax) {\n    //         return enemyMap[keyArray[0]];\n    //     } else {\n    //         return null;\n    //     }\n    // },\n    // //获取距离\n    // getTargetDistance: function (position, atkTarget) {\n    //     if (atkTarget == null || atkTarget.getComponent('person').isDie()) {\n    //         return 9999;\n    //     }\n    //     return cc.pDistance(position, atkTarget.getPosition());\n    // },\n\n    //新寻敌、攻击方法（格子版）\n    findCanAtkGrid: function (atkType, rowGrid, colGrid, atkDistMin, atkDistMax) {\n        let canAtkGrids = [];\n        let position = Number(`${rowGrid}${colGrid}`);\n        //如果是远程，获取身边一个的攻击范围\n        if (AttackType.Range == atkType) {\n            let top = position + 10;\n            let bottom = position - 10;\n            let left = position - 1;\n            let right = position + 1;\n            if(top > 0 && top <= 50){\n                canAtkGrids.push(top);\n            }\n            if(bottom > 0 && bottom <= 50){\n                canAtkGrids.push(bottom);\n            }\n            if(left > 0 && left <= 50 && left.toString().substring(0,1) == rowGrid){\n                canAtkGrids.push(left);\n            }\n            if(right > 0 && right <= 50 && right.toString().substring(0,1) == rowGrid){\n                canAtkGrids.push(right);\n            }\n        }\n        //获取最小攻击范围到最大攻击范围的格子坐标\n        for (let i = atkDistMin; i <= atkDistMax; i++) {\n            var top = position + i * 10;\n            var bottom = position - i * 10;\n            var left = position - i;\n            var right = position + i;\n            if(top > 0 && top <= 50){\n                canAtkGrids.push(top);\n            }\n            if(bottom > 0 && bottom <= 50){\n                canAtkGrids.push(bottom);\n            }\n            if(left > 0 && left <= 50 && left.toString().substring(0,1) == rowGrid){\n                canAtkGrids.push(left);\n            }\n            if(right > 0 && right <= 50 && right.toString().substring(0,1) == rowGrid){\n                canAtkGrids.push(right);\n            }\n            //斜角\n            if(i < atkDistMax){\n                var topLeft = position + i * 11;\n                var topRight = position - i * 9;\n                var bottomLeft = position - i * 11;\n                var bottomRight = position + i * 9;\n                if(topLeft > 0 && topLeft <= 50){\n                    canAtkGrids.push(topLeft);\n                }\n                if(topRight > 0 && topRight <= 50){\n                    canAtkGrids.push(topRight);\n                }\n                if(bottomLeft > 0 && bottomLeft <= 50){\n                    canAtkGrids.push(bottomLeft);\n                }\n                if(bottomRight > 0 && bottomRight <= 50){\n                    canAtkGrids.push(bottomRight);\n                }\n            }\n        }\n        return canAtkGrids;\n    },\n    findNew: function(atkType, rowGrid, colGrid, atkDistMin, atkDistMax){\n        if(js_dataControl.getHeroList() && js_dataControl.getHeroList().length > 0){\n            let canAtkGrids = this.findCanAtkGrid(atkType, rowGrid, colGrid, atkDistMin, atkDistMax);\n            //cc.log(canAtkGrids);\n            let canAtkTreget = {};\n            let gridList = [];\n            for(let grid of canAtkGrids){\n                for(let temp of js_dataControl.getHeroList()){\n                    if(temp.groupId == 2 && temp.isDie == 1){\n                        let boxId = `${temp.y}${temp.x}`;\n                        //cc.log(boxId);\n                        if(grid == boxId){\n                            canAtkTreget[temp.boxId] = temp;\n                            gridList.push(temp.boxId);\n                        }\n                    }\n                }\n            }\n            for(let i=0;i<gridList.length;i++){\n                for(let j=i;j<gridList.length;j++){\n                    if (gridList[i] > gridList[j]) {\n                        var temp = gridList[i];\n                        gridList[i] = gridList[j];\n                        gridList[j] = temp;\n                    }\n                }\n            }\n            let atkTarget = canAtkTreget[gridList[0]];\n            if(atkTarget && atkTarget instanceof Object){\n                return atkTarget.heroName;\n            }\n        }\n    },\n    /**\n     * 检测当前攻击目标是否还在攻击范围内\n     */\n    checkTargetInGrids:function(atkType, atkTargetName, rowGrid, colGrid, atkDistMin, atkDistMax){\n        for(let temp of js_dataControl.getHeroList()){\n            if(temp.heroName == atkTargetName){\n                let atkTargetBoxId = `${temp.y}${temp.x}`;\n                let canAtkGrids = this.findCanAtkGrid(atkType, rowGrid, colGrid, atkDistMin, atkDistMax);\n                for(let grid of canAtkGrids){\n                    if(atkTargetBoxId == grid){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n});\n"]}